/* TRIGGERS */

CREATE TABLE PRODUTOS(
	IDPRODUTO INT IDENTITY PRIMARY KEY,
	NOME VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECO NUMERIC(10,2) NOT NULL
)
GO

CREATE TABLE HISTORICO(
	IDOPERACAO INT IDENTITY PRIMARY KEY,
	PRODUTO VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECOANTIGO NUMERIC(10,2) NOT NULL,
	PRECONOVO NUMERIC(10,2) NOT NULL,
	DATA DATETIME,
	USUARIO VARCHAR(30),
	MENSAGEM VARCHAR(100)
)
GO

INSERT INTO PRODUTOS(NOME, CATEGORIA,PRECO)
VALUES
('LIVRO SQL SERVER','LIVROS',98.00),
('LIVRO ORACLE','LIVROS',50.00),
('LICENÇA POWERCENTER','SOFTWARES',45000.00),
('NOTEBOOK I7','COMPUTADORES',3150.00),
('LIVRO BUSINESS INTELLIGENCE','LIVROS',90.00)
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO

/* VERIFICAR USUARIO LOGADO NO BANCO */
SELECT SUSER_NAME()
GO

/* TRIGGER DE DADOS - DML */
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE
AS
	DECLARE @IDPRODUTO INT
	DECLARE @PRODUTO VARCHAR(30)
	DECLARE @CATEGORIA VARCHAR(10)
	DECLARE @PRECO NUMERIC(10,2)
	DECLARE @PRECONOVO NUMERIC(10,2)
	DECLARE @DATA DATETIME
	DECLARE @USUARIO VARCHAR(30)
	DECLARE @ACAO VARCHAR(100)

	-- UTILIZAR SELECT PARA VALORES VINDOS DE TABELAS
	SELECT @IDPRODUTO = IDPRODUTO FROM inserted
	SELECT @PRODUTO = NOME FROM inserted
	SELECT @CATEGORIA = CATEGORIA FROM inserted
	SELECT @PRECO = PRECO FROM deleted
	SELECT @PRECONOVO = PRECO FROM inserted
	
	-- UTILIZAR SET PARA VALORES VINDOS DE FUNÇÕES OU LITERAIS (BOA PRÁTICA)
	SET @DATA = GETDATE()
	SET @USUARIO = SUSER_NAME()
	SET @ACAO = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZAR_PRECO'

	-- PARA PASSAR OS VALORES A SEREM INSERIDOS, BASTA INFORMAR POR MEIO DAS VARIÁVEIS CRIADAS
	INSERT INTO HISTORICO
	(PRODUTO, CATEGORIA, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
	VALUES
	(@PRODUTO, @CATEGORIA, @PRECO, @PRECONOVO, @DATA, @USUARIO, @ACAO)
	
	PRINT 'TRIGGER EXECUTADA COM SUCESSO'

GO

DROP TRIGGER TRG_ATUALIZAR_PRODUTO

/* EXECUTANDO UPDATE PARA TESTE DE TRIGGER */

UPDATE PRODUTOS SET PRECO = 100.00
WHERE IDPRODUTO = 1
GO

/*	COMO A TRIGGER ESTÁ CONFIGURADA PARA TODAS AS COLUNAS, AO ATUALIZAR O NOME DO PRODUTO
	A MESMA ACABA SENDO ACIONADA NOVAMENTE, AO INVÉS DE GUARDAR O PRECO ANTIGO DE 98, SERÁ
	GUARDADO O ATUAL COMO 100 TAMBÉM
*/
UPDATE PRODUTOS SET NOME = 'LIVRO C#'
WHERE IDPRODUTO = 1
GO

DROP TRIGGER TRG_ATUALIZA_PRECO
GO

/* FAZENDO O AJUSTE NA TRIGGE PARA APENAS UMA COLUNA */
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO)
BEGIN

	DECLARE @IDPRODUTO INT
	DECLARE @PRODUTO VARCHAR(30)
	DECLARE @CATEGORIA VARCHAR(10)
	DECLARE @PRECO NUMERIC(10,2)
	DECLARE @PRECONOVO NUMERIC(10,2)
	DECLARE @DATA DATETIME
	DECLARE @USUARIO VARCHAR(30)
	DECLARE @ACAO VARCHAR(100)

	-- UTILIZAR SELECT PARA VALORES VINDOS DE TABELAS
	SELECT @IDPRODUTO = IDPRODUTO FROM inserted
	SELECT @PRODUTO = NOME FROM inserted
	SELECT @CATEGORIA = CATEGORIA FROM inserted
	SELECT @PRECO = PRECO FROM deleted
	SELECT @PRECONOVO = PRECO FROM inserted
	
	-- UTILIZAR SET PARA VALORES VINDOS DE FUNÇÕES OU LITERAIS (BOA PRÁTICA)
	SET @DATA = GETDATE()
	SET @USUARIO = SUSER_NAME()
	SET @ACAO = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZAR_PRECO'

	-- PARA PASSAR OS VALORES A SEREM INSERIDOS, BASTA INFORMAR POR MEIO DAS VARIÁVEIS CRIADAS
	INSERT INTO HISTORICO
	(PRODUTO, CATEGORIA, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
	VALUES
	(@PRODUTO, @CATEGORIA, @PRECO, @PRECONOVO, @DATA, @USUARIO, @ACAO)
	
	PRINT 'TRIGGER EXECUTADA COM SUCESSO'

END
GO

UPDATE PRODUTOS SET PRECO = 300.00
WHERE IDPRODUTO = 2
GO

UPDATE PRODUTOS SET NOME = 'LIVRO JAVA'
WHERE IDPRODUTO = 2
GO


/*	REPETINDO O PROCESSO DA CRIAÇÃO DE UMA TRIGGER, ASSIM COMO É POSSÍVEL QUE UMA TRIGGER
	OLHE A TABELA EM GERAL E UMA ÚNICA COLUNA, PODE SER FEITO A MESMA TRIGGER OLHAR MAIS QUE UMA COLUNA
 */

CREATE TABLE PRODUTOS(
	IDPRODUTO INT IDENTITY PRIMARY KEY,
	NOME VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECO NUMERIC(10,2) NOT NULL
)
GO

CREATE TABLE HISTORICO(
	IDOPERACAO INT IDENTITY PRIMARY KEY,
	PRODUTO VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	NOMEANTIGO VARCHAR(50) NOT NULL,
	NOMENOVO VARCHAR(50) NOT NULL,
	PRECOANTIGO NUMERIC(10,2) NOT NULL,
	PRECONOVO NUMERIC(10,2) NOT NULL,
	DATA DATETIME,
	USUARIO VARCHAR(30),
	MENSAGEM VARCHAR(100)
)
GO

INSERT INTO PRODUTOS(NOME, CATEGORIA,PRECO)
VALUES
('LIVRO SQL SERVER','LIVROS',98.00),
('LIVRO ORACLE','LIVROS',50.00),
('LICENÇA POWERCENTER','SOFTWARES',45000.00),
('NOTEBOOK I7','COMPUTADORES',3150.00),
('LIVRO BUSINESS INTELLIGENCE','LIVROS',90.00)
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO

drop trigger TRG_ATUALIZA_PRECO
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO) OR UPDATE(NOME)
BEGIN

	DECLARE @IDPRODUTO INT
	DECLARE @PRODUTO VARCHAR(30)
	DECLARE @CATEGORIA VARCHAR(10)
	DECLARE @NOME VARCHAR(50)
	DECLARE @NOMENOVO VARCHAR(50)
	DECLARE @PRECO NUMERIC(10,2)
	DECLARE @PRECONOVO NUMERIC(10,2)
	DECLARE @DATA DATETIME
	DECLARE @USUARIO VARCHAR(30)
	DECLARE @ACAO VARCHAR(100)

	-- UTILIZAR SELECT PARA VALORES VINDOS DE TABELAS
	SELECT @IDPRODUTO = IDPRODUTO FROM inserted
	SELECT @PRODUTO = NOME FROM inserted
	SELECT @CATEGORIA = CATEGORIA FROM inserted
	SELECT @NOME = NOME FROM deleted
	SELECT @NOMENOVO = NOME FROM inserted
	SELECT @PRECO = PRECO FROM deleted
	SELECT @PRECONOVO = PRECO FROM inserted
	
	-- UTILIZAR SET PARA VALORES VINDOS DE FUNÇÕES OU LITERAIS (BOA PRÁTICA)
	SET @DATA = GETDATE()
	SET @USUARIO = SUSER_NAME()
	SET @ACAO = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZAR_PRECO'

	-- PARA PASSAR OS VALORES A SEREM INSERIDOS, BASTA INFORMAR POR MEIO DAS VARIÁVEIS CRIADAS
	INSERT INTO HISTORICO
	(PRODUTO, CATEGORIA, NOMEANTIGO, NOMENOVO, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
	VALUES
	(@PRODUTO, @CATEGORIA, @NOME, @NOMENOVO, @PRECO, @PRECONOVO, @DATA, @USUARIO, @ACAO)
	
	PRINT 'TRIGGER EXECUTADA COM SUCESSO'

END
GO


/* VARIAVEIS COM SELECT */

SELECT 10 + 10
GO

CREATE TABLE RESULTADO(
	IDRESULTADO INT PRIMARY KEY IDENTITY,
	RESULTADO INT
)
GO

INSERT INTO RESULTADO VALUES ((SELECT 10 + 10))
GO

SELECT * FROM RESULTADO

/* ATRIBUIR SELECT A UMA VARIÁVEL - ANONIMO */

DECLARE
	@RESULTADO INT
	SET @RESULTADO = (SELECT 50 + 50)
	INSERT INTO RESULTADO VALUES (@RESULTADO)
	PRINT 'VALO INSERIDO: ' + CAST(@RESULTADO AS VARCHAR)
GO

DECLARE
	@RESULTADO INT
	SET @RESULTADO = (SELECT 50 + 50)
	INSERT INTO RESULTADO VALUES (@RESULTADO)
GO

/* TRIGGER UPDATE */

CREATE TABLE EMPREGADO(
	IDEMPREGADO INT PRIMARY KEY,
	NOME VARCHAR(30),
	SALARIO MONEY,
	IDGERENTE INT
)
GO

ALTER TABLE EMPREGADO ADD CONSTRAINT FK_GERENTE
FOREIGN KEY(IDGERENTE) REFERENCES EMPREGADO(IDEMPREGADO)
GO

INSERT INTO EMPREGADO (IDEMPREGADO, NOME, SALARIO, IDGERENTE)
VALUES
(1,'CLARA',5000.00,NULL),
(2,'CELIA',4000.00,1),
(3,'JOAO',4000.00,1)
GO

CREATE TABLE HISTORICO_SALARIO(
	IDEMPREGADO INT,
	SALARIO_ANTERIOR MONEY,
	SALARIO_NOVO MONEY,
	DATA DATETIME
)
GO

CREATE TRIGGER TRG_SALARIO
ON DBO.EMPREGADO
FOR UPDATE AS
IF UPDATE(SALARIO)
BEGIN

	INSERT INTO HISTORICO_SALARIO
	(IDEMPREGADO, SALARIO_ANTERIOR, SALARIO_NOVO, DATA)
	SELECT D.IDEMPREGADO, D.SALARIO, I.SALARIO, GETDATE()
	FROM deleted D, inserted I
	WHERE D.IDEMPREGADO = I.IDEMPREGADO

END
GO

UPDATE EMPREGADO SET SALARIO = SALARIO * 1.1
GO

SELECT * FROM HISTORICO_SALARIO
SELECT * FROM EMPREGADO

SELECT	H.IDEMPREGADO,
		E.NOME,
		H.SALARIO_ANTERIOR,
		H.SALARIO_NOVO,
		H.DATA
FROM HISTORICO_SALARIO H
INNER JOIN EMPREGADO E
ON H.IDEMPREGADO = E.IDEMPREGADO
GO

/* CRIANDO UM NOVO CENÁRIO PARA TESTE COM TRIGGERS */

CREATE TABLE SALARIO_RANGE(
	MINSAL MONEY,
	MAXSAL MONEY
)
GO

INSERT INTO SALARIO_RANGE
VALUES
(3000.00,6000.00)
GO

SELECT * FROM SALARIO_RANGE

/* PODE SER CRIADO UMA TRIGGER TAMBÉM COLOCANDO MAIS DE UM TIPO DE ACIONAMENTO (INSERT,UPDATE,DELETE) */

CREATE TRIGGER TRG_RANGE
ON DBO.EMPREGADO
FOR INSERT,UPDATE
AS
	-- PODE SER DECLARADO MAIS VARIÁVEIS DE UMA ÚNICA VEZ
	DECLARE
		@MINSAL MONEY,
		@MAXSAL MONEY,
		@ATUALSAL MONEY
	
	-- TAMBÉM PODE SER ATRIBUÍDO OS VALORES AS VARIÁVEIS ATRAVÉS DE UM SELECT DE UMA ÚNICA VEZ
	SELECT @MINSAL = MINSAL, @MAXSAL = MAXSAL FROM SALARIO_RANGE

	SELECT @ATUALSAL = I.SALARIO
	FROM inserted I

	IF(@ATUALSAL < @MINSAL)
	BEGIN
		-- (16,1) GERALMENTE LIGADO A ERRO DE USUÁRIO
		RAISERROR('SALÁRIO MENOR QUE O PISO', 16,1)
		-- DESFAZ AS ALTERAÇÕES REALIZADAS
		ROLLBACK TRANSACTION
	END

	IF(@ATUALSAL > @MAXSAL)
	BEGIN
		RAISERROR('SALÁRIO MAIOR QUE O TETO', 16,1)
		-- DESFAZ AS ALTERAÇÕES REALIZADAS
		ROLLBACK TRANSACTION
	END

GO

UPDATE EMPREGADO SET SALARIO = 9000.00
WHERE IDEMPREGADO = 1
GO

UPDATE EMPREGADO SET SALARIO = 1000.00
WHERE IDEMPREGADO = 1
GO

/* VERIFICAR TEXTO DE TRIGGER */

SP_HELPTEXT TRG_RANGE
GO