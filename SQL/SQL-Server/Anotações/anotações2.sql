/* TRABALHANDO COM DATAS */
/* GETDATE PEGA A DATA ATUAL */
SELECT GETDATE()
GO

/*	DATEDIFF - TRAS A DIFERENÇA ENTRE UMA DATA
	DATEDIFF(DIA/MES/ANO, COLUNA(INICIAL), COLUNA(FINAL))
*/	
SELECT NOME, DATEDIFF(DAY, NASCIMENTO, GETDATE()) AS "NASCIMENTO"
FROM ALUNO
GO

SELECT NOME, DATEDIFF(YEAR, NASCIMENTO, GETDATE()) AS "NASCIMENTO"
FROM ALUNO
GO

/* COMO O VALOR RETORNADO É UM INTEIRO, PODE SER FEITO OPERAÇÕES MATEMATICAS */
SELECT NOME, (DATEDIFF(DAY, NASCIMENTO, GETDATE())/365) AS "NASCIMENTO"
FROM ALUNO
GO

SELECT NOME, (DATEDIFF(MONTH, NASCIMENTO, GETDATE())/12) AS "NASCIMENTO"
FROM ALUNO
GO

/* DATENAME - TRAS O NOME DA DATA */
SELECT NOME, DATENAME(YEAR, NASCIMENTO)
FROM ALUNO
GO

SELECT NOME, DATENAME(MONTH, NASCIMENTO)
FROM ALUNO
GO

SELECT NOME, DATENAME(WEEKDAY, NASCIMENTO)
FROM ALUNO
GO

/* DATEPART - TRAS O VALOR INTEIRO */
SELECT NOME, DATEPART(DAY, NASCIMENTO)
FROM ALUNO
GO

SELECT NOME, DATEPART(MONTH, NASCIMENTO), DATENAME(MONTH, NASCIMENTO)
FROM ALUNO
GO

SELECT NOME, DATEPART(YEAR, NASCIMENTO)
FROM ALUNO
GO

/* DATEADD - RETORNA A DATA COM SOMA */
SELECT DATEADD(YEAR, 300, GETDATE())
GO

/* CONVERSÃO DE DADOS */

SELECT 1 + '1'
GO

SELECT '1' + '1'
GO

/* IRA RETORNAR UM ERRO POR CONTA DA CONVERSÃO IMPLICITA */
SELECT 'BANCO DE DADOS' + 1
GO

/* FUNÇÕES DE CONVERSÃO (conversão explicita) */
SELECT CAST('1' AS INT) + CAST('1' AS INT)
GO

/* IRA RETORNAR UM ERRO, POR CONTA DA TENTATIVA DE CONVERSÃO DE "/" PARA UM VALOR NÚMERICO */
SELECT NOME,
DATEPART(DAY, NASCIMENTO)+'/'+
DATEPART(MONTH, NASCIMENTO)+'/'+
DATEPART(YEAR, NASCIMENTO) AS "NASCIMENTO"
FROM ALUNO
GO

SELECT NOME,
CAST(DATEPART(DAY, NASCIMENTO) AS VARCHAR)+'/'+
CAST(DATEPART(MONTH, NASCIMENTO) AS VARCHAR)+'/'+
CAST(DATEPART(YEAR, NASCIMENTO) AS VARCHAR) AS "NASCIMENTO"
FROM ALUNO
GO

/*	CHARINDEX - RETORNA UM VALOR INTEIRO
	CHARINDEX(O QUE PROCURAR, ONDE, A PARTIR DE(POSIÇÃO))
	CONTAGEM DEFAULT INICIA EM 1
*/

SELECT NOME, CHARINDEX('A', NOME)
FROM ALUNO
GO

SELECT NOME, CHARINDEX('A', NOME, 2)
FROM ALUNO
GO

/* BULK INSERT - IMPORTAÇÃO DE ARQUIVOS */

CREATE TABLE LANCAMENTO_CONTABIL(
	CONTA INT,
	VALOR INT,
	DEB_CRED CHAR(1)
)
GO

SELECT * FROM LANCAMENTO_CONTABIL
GO

/* PODERIA SER USADO EM FIELDTERMINATOR UM ";" PARA INDICAR A COLUNA/FINAL DO CAMPO */
BULK INSERT LANCAMENTO_CONTABIL
FROM 'C:\Users\di_an\OneDrive\Documentos\GitHub\Estudo-Pratica-Geral\SQL\SQL-Server\Arquivos\CONTAS.txt'
WITH
(
	FIRSTROW = 2,
	DATAFILETYPE = 'char',
	FIELDTERMINATOR = '\t',
	ROWTERMINATOR = '\n'
)
GO

delete from LANCAMENTO_CONTABIL

/* ENCONTRANDO SALDO */
SELECT CONTA, VALOR,
CHARINDEX('D', DEB_CRED) AS DEBITO,
CHARINDEX('C', DEB_CRED) AS CREDITO,
CHARINDEX('C', DEB_CRED ) * 2 - 1 AS MULTIPLICADOR
FROM LANCAMENTO_CONTABIL 
GO

SELECT CONTA,
SUM(VALOR * (CHARINDEX('C', DEB_CRED ) * 2 - 1)) AS "SALDO"
FROM LANCAMENTO_CONTABIL
GROUP BY CONTA
GO

/* TRIGGERS */

CREATE TABLE PRODUTOS(
	IDPRODUTO INT IDENTITY PRIMARY KEY,
	NOME VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECO NUMERIC(10,2) NOT NULL
)
GO

CREATE TABLE HISTORICO(
	IDOPERACAO INT IDENTITY PRIMARY KEY,
	PRODUTO VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECOANTIGO NUMERIC(10,2) NOT NULL,
	PRECONOVO NUMERIC(10,2) NOT NULL,
	DATA DATETIME,
	USUARIO VARCHAR(30),
	MENSAGEM VARCHAR(100)
)
GO

INSERT INTO PRODUTOS(NOME, CATEGORIA,PRECO)
VALUES
('LIVRO SQL SERVER','LIVROS',98.00),
('LIVRO ORACLE','LIVROS',50.00),
('LICENÇA POWERCENTER','SOFTWARES',45000.00),
('NOTEBOOK I7','COMPUTADORES',3150.00),
('LIVRO BUSINESS INTELLIGENCE','LIVROS',90.00)
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO

/* VERIFICAR USUARIO LOGADO NO BANCO */
SELECT SUSER_NAME()
GO

/* TRIGGER DE DADOS - DML */
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE
AS
	DECLARE @IDPRODUTO INT
	DECLARE @PRODUTO VARCHAR(30)
	DECLARE @CATEGORIA VARCHAR(10)
	DECLARE @PRECO NUMERIC(10,2)
	DECLARE @PRECONOVO NUMERIC(10,2)
	DECLARE @DATA DATETIME
	DECLARE @USUARIO VARCHAR(30)
	DECLARE @ACAO VARCHAR(100)

	-- UTILIZAR SELECT PARA VALORES VINDOS DE TABELAS
	SELECT @IDPRODUTO = IDPRODUTO FROM inserted
	SELECT @PRODUTO = NOME FROM inserted
	SELECT @CATEGORIA = CATEGORIA FROM inserted
	SELECT @PRECO = PRECO FROM deleted
	SELECT @PRECONOVO = PRECO FROM inserted
	
	-- UTILIZAR SET PARA VALORES VINDOS DE FUNÇÕES OU LITERAIS (BOA PRÁTICA)
	SET @DATA = GETDATE()
	SET @USUARIO = SUSER_NAME()
	SET @ACAO = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZAR_PRECO'

	-- PARA PASSAR OS VALORES A SEREM INSERIDOS, BASTA INFORMAR POR MEIO DAS VARIÁVEIS CRIADAS
	INSERT INTO HISTORICO
	(PRODUTO, CATEGORIA, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
	VALUES
	(@PRODUTO, @CATEGORIA, @PRECO, @PRECONOVO, @DATA, @USUARIO, @ACAO)
	
	PRINT 'TRIGGER EXECUTADA COM SUCESSO'

GO

DROP TRIGGER TRG_ATUALIZAR_PRODUTO

/* EXECUTANDO UPDATE PARA TESTE DE TRIGGER */

UPDATE PRODUTOS SET PRECO = 100.00
WHERE IDPRODUTO = 1
GO

/*	COMO A TRIGGER ESTÁ CONFIGURADA PARA TODAS AS COLUNAS, AO ATUALIZAR O NOME DO PRODUTO
	A MESMA ACABA SENDO ACIONADA NOVAMENTE, AO INVÉS DE GUARDAR O PRECO ANTIGO DE 98, SERÁ
	GUARDADO O ATUAL COMO 100 TAMBÉM
*/
UPDATE PRODUTOS SET NOME = 'LIVRO C#'
WHERE IDPRODUTO = 1
GO

DROP TRIGGER TRG_ATUALIZA_PRECO
GO

/* FAZENDO O AJUSTE NA TRIGGE PARA APENAS UMA COLUNA */
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO)
BEGIN

	DECLARE @IDPRODUTO INT
	DECLARE @PRODUTO VARCHAR(30)
	DECLARE @CATEGORIA VARCHAR(10)
	DECLARE @PRECO NUMERIC(10,2)
	DECLARE @PRECONOVO NUMERIC(10,2)
	DECLARE @DATA DATETIME
	DECLARE @USUARIO VARCHAR(30)
	DECLARE @ACAO VARCHAR(100)

	-- UTILIZAR SELECT PARA VALORES VINDOS DE TABELAS
	SELECT @IDPRODUTO = IDPRODUTO FROM inserted
	SELECT @PRODUTO = NOME FROM inserted
	SELECT @CATEGORIA = CATEGORIA FROM inserted
	SELECT @PRECO = PRECO FROM deleted
	SELECT @PRECONOVO = PRECO FROM inserted
	
	-- UTILIZAR SET PARA VALORES VINDOS DE FUNÇÕES OU LITERAIS (BOA PRÁTICA)
	SET @DATA = GETDATE()
	SET @USUARIO = SUSER_NAME()
	SET @ACAO = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZAR_PRECO'

	-- PARA PASSAR OS VALORES A SEREM INSERIDOS, BASTA INFORMAR POR MEIO DAS VARIÁVEIS CRIADAS
	INSERT INTO HISTORICO
	(PRODUTO, CATEGORIA, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
	VALUES
	(@PRODUTO, @CATEGORIA, @PRECO, @PRECONOVO, @DATA, @USUARIO, @ACAO)
	
	PRINT 'TRIGGER EXECUTADA COM SUCESSO'

END
GO

UPDATE PRODUTOS SET PRECO = 300.00
WHERE IDPRODUTO = 2
GO

UPDATE PRODUTOS SET NOME = 'LIVRO JAVA'
WHERE IDPRODUTO = 2
GO


/*	REPETINDO O PROCESSO DA CRIAÇÃO DE UMA TRIGGER, ASSIM COMO É POSSÍVEL QUE UMA TRIGGER
	OLHE A TABELA EM GERAL E UMA ÚNICA COLUNA, PODE SER FEITO A MESMA TRIGGER OLHAR MAIS QUE UMA COLUNA
 */

CREATE TABLE PRODUTOS(
	IDPRODUTO INT IDENTITY PRIMARY KEY,
	NOME VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECO NUMERIC(10,2) NOT NULL
)
GO

CREATE TABLE HISTORICO(
	IDOPERACAO INT IDENTITY PRIMARY KEY,
	PRODUTO VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	NOMEANTIGO VARCHAR(50) NOT NULL,
	NOMENOVO VARCHAR(50) NOT NULL,
	PRECOANTIGO NUMERIC(10,2) NOT NULL,
	PRECONOVO NUMERIC(10,2) NOT NULL,
	DATA DATETIME,
	USUARIO VARCHAR(30),
	MENSAGEM VARCHAR(100)
)
GO

INSERT INTO PRODUTOS(NOME, CATEGORIA,PRECO)
VALUES
('LIVRO SQL SERVER','LIVROS',98.00),
('LIVRO ORACLE','LIVROS',50.00),
('LICENÇA POWERCENTER','SOFTWARES',45000.00),
('NOTEBOOK I7','COMPUTADORES',3150.00),
('LIVRO BUSINESS INTELLIGENCE','LIVROS',90.00)
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO

drop trigger TRG_ATUALIZA_PRECO
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO) OR UPDATE(NOME)
BEGIN

	DECLARE @IDPRODUTO INT
	DECLARE @PRODUTO VARCHAR(30)
	DECLARE @CATEGORIA VARCHAR(10)
	DECLARE @NOME VARCHAR(50)
	DECLARE @NOMENOVO VARCHAR(50)
	DECLARE @PRECO NUMERIC(10,2)
	DECLARE @PRECONOVO NUMERIC(10,2)
	DECLARE @DATA DATETIME
	DECLARE @USUARIO VARCHAR(30)
	DECLARE @ACAO VARCHAR(100)

	-- UTILIZAR SELECT PARA VALORES VINDOS DE TABELAS
	SELECT @IDPRODUTO = IDPRODUTO FROM inserted
	SELECT @PRODUTO = NOME FROM inserted
	SELECT @CATEGORIA = CATEGORIA FROM inserted
	SELECT @NOME = NOME FROM deleted
	SELECT @NOMENOVO = NOME FROM inserted
	SELECT @PRECO = PRECO FROM deleted
	SELECT @PRECONOVO = PRECO FROM inserted
	
	-- UTILIZAR SET PARA VALORES VINDOS DE FUNÇÕES OU LITERAIS (BOA PRÁTICA)
	SET @DATA = GETDATE()
	SET @USUARIO = SUSER_NAME()
	SET @ACAO = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZAR_PRECO'

	-- PARA PASSAR OS VALORES A SEREM INSERIDOS, BASTA INFORMAR POR MEIO DAS VARIÁVEIS CRIADAS
	INSERT INTO HISTORICO
	(PRODUTO, CATEGORIA, NOMEANTIGO, NOMENOVO, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
	VALUES
	(@PRODUTO, @CATEGORIA, @NOME, @NOMENOVO, @PRECO, @PRECONOVO, @DATA, @USUARIO, @ACAO)
	
	PRINT 'TRIGGER EXECUTADA COM SUCESSO'

END
GO


/* VARIAVEIS COM SELECT */

SELECT 10 + 10
GO

CREATE TABLE RESULTADO(
	IDRESULTADO INT PRIMARY KEY IDENTITY,
	RESULTADO INT
)
GO

INSERT INTO RESULTADO VALUES ((SELECT 10 + 10))
GO

SELECT * FROM RESULTADO

/* ATRIBUIR SELECT A UMA VARIÁVEL - ANONIMO */

DECLARE
	@RESULTADO INT
	SET @RESULTADO = (SELECT 50 + 50)
	INSERT INTO RESULTADO VALUES (@RESULTADO)
	PRINT 'VALO INSERIDO: ' + CAST(@RESULTADO AS VARCHAR)
GO

DECLARE
	@RESULTADO INT
	SET @RESULTADO = (SELECT 50 + 50)
	INSERT INTO RESULTADO VALUES (@RESULTADO)
GO

/* TRIGGER UPDATE */

CREATE TABLE EMPREGADO(
	IDEMPREGADO INT PRIMARY KEY,
	NOME VARCHAR(30),
	SALARIO MONEY,
	IDGERENTE INT
)
GO

ALTER TABLE EMPREGADO ADD CONSTRAINT FK_GERENTE
FOREIGN KEY(IDGERENTE) REFERENCES EMPREGADO(IDEMPREGADO)
GO

INSERT INTO EMPREGADO (IDEMPREGADO, NOME, SALARIO, IDGERENTE)
VALUES
(1,'CLARA',5000.00,NULL),
(2,'CELIA',4000.00,1),
(3,'JOAO',4000.00,1)
GO

CREATE TABLE HISTORICO_SALARIO(
	IDEMPREGADO INT,
	SALARIO_ANTERIOR MONEY,
	SALARIO_NOVO MONEY,
	DATA DATETIME
)
GO

CREATE TRIGGER TRG_SALARIO
ON DBO.EMPREGADO
FOR UPDATE AS
IF UPDATE(SALARIO)
BEGIN

	INSERT INTO HISTORICO_SALARIO
	(IDEMPREGADO, SALARIO_ANTERIOR, SALARIO_NOVO, DATA)
	SELECT D.IDEMPREGADO, D.SALARIO, I.SALARIO, GETDATE()
	FROM deleted D, inserted I
	WHERE D.IDEMPREGADO = I.IDEMPREGADO

END
GO

UPDATE EMPREGADO SET SALARIO = SALARIO * 1.1
GO

SELECT * FROM HISTORICO_SALARIO
SELECT * FROM EMPREGADO

SELECT	H.IDEMPREGADO,
		E.NOME,
		H.SALARIO_ANTERIOR,
		H.SALARIO_NOVO,
		H.DATA
FROM HISTORICO_SALARIO H
INNER JOIN EMPREGADO E
ON H.IDEMPREGADO = E.IDEMPREGADO
GO

/*  */